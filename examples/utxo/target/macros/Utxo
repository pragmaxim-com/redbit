pub const UTXO_ID: ::redb::TableDefinition<'static, Bincode<UtxoPointer>, ()> = ::redb::TableDefinition::new(
    "UTXO_ID",
);
pub const UTXO_AMOUNT_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<UtxoPointer>,
    Bincode<Amount>,
> = ::redb::TableDefinition::new("UTXO_AMOUNT_BY_ID");
pub const UTXO_DATUM_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<UtxoPointer>,
    Bincode<Datum>,
> = ::redb::TableDefinition::new("UTXO_DATUM_BY_ID");
pub const UTXO_DATUM_INDEX: ::redb::MultimapTableDefinition<
    'static,
    Bincode<Datum>,
    Bincode<UtxoPointer>,
> = ::redb::MultimapTableDefinition::new("UTXO_DATUM_INDEX");
pub const UTXO_ADDRESS_DICT_INDEX: ::redb::MultimapTableDefinition<
    'static,
    Bincode<UtxoPointer>,
    Bincode<UtxoPointer>,
> = ::redb::MultimapTableDefinition::new("UTXO_ADDRESS_DICT_INDEX");
pub const UTXO_ADDRESS_BY_DICT_PK: ::redb::TableDefinition<
    'static,
    Bincode<UtxoPointer>,
    Bincode<Address>,
> = ::redb::TableDefinition::new("UTXO_ADDRESS_BY_DICT_PK");
pub const UTXO_ADDRESS_TO_DICT_PK: ::redb::TableDefinition<
    'static,
    Bincode<Address>,
    Bincode<UtxoPointer>,
> = ::redb::TableDefinition::new("UTXO_ADDRESS_TO_DICT_PK");
pub const UTXO_ADDRESS_DICT_PK_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<UtxoPointer>,
    Bincode<UtxoPointer>,
> = ::redb::TableDefinition::new("UTXO_ADDRESS_DICT_PK_BY_ID");
#[axum::debug_handler]
pub async fn utxo_get(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<UtxoPointer>>,
) -> Result<AppJson<Option<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::get(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_take(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(params): ::axum::extract::Query<TakeParams>,
) -> Result<AppJson<Vec<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::take(&read_tx, params.take))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_first(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(params): ::axum::extract::Query<FirstParams>,
) -> Result<AppJson<Option<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::first(&read_tx))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_last(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(params): ::axum::extract::Query<LastParams>,
) -> Result<AppJson<Option<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::last(&read_tx))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_exists(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<UtxoPointer>>,
) -> Result<AppJson<bool>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::exists(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_parent_pk(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<UtxoPointer>>,
) -> Result<AppJson<<UtxoPointer as ChildPointer>::Parent>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::parent_pk(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_range(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(
        params,
    ): ::axum::extract::Query<RequestRangeParams<UtxoPointer, UtxoPointer>>,
) -> Result<AppJson<Vec<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::range(&read_tx, &params.from, &params.until))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_get_by_datum(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<Datum>>,
) -> Result<AppJson<Vec<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::get_by_datum(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_get_by_address(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<Address>>,
) -> Result<AppJson<Vec<Utxo>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::get_by_address(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn utxo_get_assets(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<UtxoPointer>>,
) -> Result<AppJson<Vec<Asset>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| Utxo::get_assets(&read_tx, &params.value))
        .map(AppJson)
}
impl Utxo {
    pub fn get(
        read_tx: &::redb::ReadTransaction,
        pk: &UtxoPointer,
    ) -> Result<Option<Utxo>, AppError> {
        let table_pk_5 = read_tx.open_table(UTXO_ID)?;
        if table_pk_5.get(pk)?.is_some() {
            Ok(Some(Self::compose(&read_tx, pk)?))
        } else {
            Ok(None)
        }
    }
    pub fn take(
        read_tx: &::redb::ReadTransaction,
        n: u32,
    ) -> Result<Vec<Utxo>, AppError> {
        let table_pk_6 = read_tx.open_table(UTXO_ID)?;
        let mut iter = table_pk_6.iter()?;
        let mut results = Vec::new();
        let mut count = 0;
        while let Some(entry_res) = iter.next() {
            if count >= n {
                break;
            }
            let pk = entry_res?.0.value();
            results.push(Self::compose(&read_tx, &pk)?);
            count += 1;
        }
        Ok(results)
    }
    pub fn first(read_tx: &::redb::ReadTransaction) -> Result<Option<Utxo>, AppError> {
        let table_pk_7 = read_tx.open_table(UTXO_ID)?;
        if let Some((k, _)) = table_pk_7.first()? {
            return Self::compose(&read_tx, &k.value()).map(Some);
        }
        Ok(None)
    }
    pub fn last(read_tx: &::redb::ReadTransaction) -> Result<Option<Utxo>, AppError> {
        let table_pk_8 = read_tx.open_table(UTXO_ID)?;
        if let Some((k, _)) = table_pk_8.last()? {
            return Self::compose(&read_tx, &k.value()).map(Some);
        }
        Ok(None)
    }
    pub fn exists(
        read_tx: &::redb::ReadTransaction,
        pk: &UtxoPointer,
    ) -> Result<bool, AppError> {
        let table_pk_11 = read_tx.open_table(UTXO_ID)?;
        if table_pk_11.get(pk)?.is_some() { Ok(true) } else { Ok(false) }
    }
    pub fn parent_pk(
        read_tx: &::redb::ReadTransaction,
        pk: &UtxoPointer,
    ) -> Result<<UtxoPointer as ChildPointer>::Parent, AppError> {
        Ok(pk.parent().clone())
    }
    pub fn range(
        read_tx: &::redb::ReadTransaction,
        from: &UtxoPointer,
        until: &UtxoPointer,
    ) -> Result<Vec<Utxo>, AppError> {
        let table_pk_9 = read_tx.open_table(UTXO_ID)?;
        let range = from.clone()..until.clone();
        let mut iter = table_pk_9.range(range)?;
        let mut results = Vec::new();
        while let Some(entry_res) = iter.next() {
            let pk = entry_res?.0.value();
            results.push(Self::compose(&read_tx, &pk)?);
        }
        Ok(results)
    }
    fn pk_range(
        write_tx: &::redb::WriteTransaction,
        from: &UtxoPointer,
        until: &UtxoPointer,
    ) -> Result<Vec<UtxoPointer>, AppError> {
        let table_pk_10 = write_tx.open_table(UTXO_ID)?;
        let range = from.clone()..until.clone();
        let mut iter = table_pk_10.range(range)?;
        let mut results = Vec::new();
        while let Some(entry_res) = iter.next() {
            let pk = entry_res?.0.value();
            results.push(pk);
        }
        Ok(results)
    }
    pub fn get_by_datum(
        read_tx: &::redb::ReadTransaction,
        val: &Datum,
    ) -> Result<Vec<Utxo>, AppError> {
        let mm_table = read_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
        let mut iter = mm_table.get(val)?;
        let mut results = Vec::new();
        while let Some(x) = iter.next() {
            let pk = x?.value();
            match Self::compose(&read_tx, &pk) {
                Ok(item) => {
                    results.push(item);
                }
                Err(err) => {
                    return Err(AppError::Internal(err.to_string()));
                }
            }
        }
        Ok(results)
    }
    pub fn get_by_address(
        read_tx: &::redb::ReadTransaction,
        val: &Address,
    ) -> Result<Vec<Utxo>, AppError> {
        let val2birth = read_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
        let birth_guard = val2birth.get(val)?;
        let birth_id = match birth_guard {
            Some(g) => g.value().clone(),
            None => return Ok(Vec::new()),
        };
        let birth2pks = read_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
        let mut iter = birth2pks.get(&birth_id)?;
        let mut results = Vec::new();
        while let Some(x) = iter.next() {
            let pk = x?.value();
            match Self::compose(&read_tx, &pk) {
                Ok(item) => {
                    results.push(item);
                }
                Err(err) => {
                    return Err(AppError::Internal(err.to_string()));
                }
            }
        }
        Ok(results)
    }
    pub fn get_assets(
        read_tx: &::redb::ReadTransaction,
        pk: &UtxoPointer,
    ) -> Result<Vec<Asset>, AppError> {
        let (from, to) = pk.fk_range();
        Asset::range(&read_tx, &from, &to)
    }
    pub fn sample(pk: &UtxoPointer) -> Self {
        Utxo {
            id: pk.clone(),
            amount: Amount::default(),
            datum: Datum::default(),
            address: Address::default(),
            assets: {
                let (from, _) = pk.fk_range();
                let sample_0 = Asset::sample(&from);
                let sample_1 = Asset::sample(&from.next());
                let sample_2 = Asset::sample(&from.next().next());
                vec![sample_0, sample_1, sample_2]
            },
        }
    }
    fn compose(
        read_tx: &::redb::ReadTransaction,
        pk: &UtxoPointer,
    ) -> Result<Utxo, AppError> {
        Ok(Utxo {
            id: pk.clone(),
            amount: {
                let table_col_5 = read_tx.open_table(UTXO_AMOUNT_BY_ID)?;
                let guard = table_col_5.get(pk)?;
                guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table `{}`: no row for primary key {:?}",
                            stringify!(UTXO_AMOUNT_BY_ID), pk
                        ),
                    ))?
                    .value()
            },
            datum: {
                let table_col_10 = read_tx.open_table(UTXO_DATUM_BY_ID)?;
                let guard = table_col_10.get(pk)?;
                guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table `{}`: no row for primary key {:?}",
                            stringify!(UTXO_DATUM_BY_ID), pk
                        ),
                    ))?
                    .value()
            },
            address: {
                let pk2birth = read_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
                let birth_guard = pk2birth.get(pk)?;
                let birth_id = birth_guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table_dict_pk_by_pk_ident `{}`: no row for primary key {:?}",
                            stringify!(UTXO_ADDRESS_DICT_PK_BY_ID), pk
                        ),
                    ))?
                    .value();
                let birth2val = read_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
                let val_guard = birth2val.get(&birth_id)?;
                val_guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table_value_by_dict_pk `{}`: no row for birth id {:?}",
                            stringify!(UTXO_ADDRESS_BY_DICT_PK), birth_id
                        ),
                    ))?
                    .value()
            },
            assets: {
                let (from, to) = pk.fk_range();
                Asset::range(read_tx, &from, &to)?
            },
        })
    }
    pub fn store(
        write_tx: &::redb::WriteTransaction,
        instance: &Utxo,
    ) -> Result<(), AppError> {
        if is_one_to_many_child && instance.exists(id.parent()) {
            let mut table_pk_1 = write_tx.open_table(UTXO_ID)?;
            table_pk_1.insert(&instance.id, ())?;
            let mut table_col_1 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
            table_col_1.insert(&instance.id, &instance.amount)?;
            let mut table_col_6 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.datum)?;
            let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
            mm.insert(&instance.datum, &instance.id)?;
            let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
            let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
            let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
            let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
            let (birth_id, newly_created) = {
                if let Some(guard) = value_to_dict_pk.get(&instance.address)? {
                    (guard.value().clone(), false)
                } else {
                    let new_birth = instance.id.clone();
                    (new_birth, true)
                }
            };
            if newly_created {
                value_to_dict_pk.insert(&instance.address, &birth_id)?;
                value_by_dict_pk.insert(&birth_id, &instance.address)?;
            }
            dict_pk_by_pk.insert(&instance.id, &birth_id)?;
            dict_index.insert(&birth_id, &instance.id)?;
            Asset::store_many(&write_tx, &instance.assets)?;
            Ok(())
        } else {
            Err(
                AppError::InvalidPrimaryKey(
                    format!("Cannot store {} with no primary key", stringify!(Utxo)),
                ),
            )
        }
    }
    pub fn store(
        write_tx: &::redb::WriteTransaction,
        instance: &Utxo,
    ) -> Result<(), AppError> {
        let mut table_pk_1 = write_tx.open_table(UTXO_ID)?;
        table_pk_1.insert(&instance.id, ())?;
        let mut table_col_1 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
        table_col_1.insert(&instance.id, &instance.amount)?;
        let mut table_col_6 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
        table_col_6.insert(&instance.id, &instance.datum)?;
        let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
        mm.insert(&instance.datum, &instance.id)?;
        let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
        let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
        let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
        let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
        let (birth_id, newly_created) = {
            if let Some(guard) = value_to_dict_pk.get(&instance.address)? {
                (guard.value().clone(), false)
            } else {
                let new_birth = instance.id.clone();
                (new_birth, true)
            }
        };
        if newly_created {
            value_to_dict_pk.insert(&instance.address, &birth_id)?;
            value_by_dict_pk.insert(&birth_id, &instance.address)?;
        }
        dict_pk_by_pk.insert(&instance.id, &birth_id)?;
        dict_index.insert(&birth_id, &instance.id)?;
        Asset::store_many(&write_tx, &instance.assets)?;
        Ok(())
    }
    pub fn store_many(
        write_tx: &::redb::WriteTransaction,
        instances: &Vec<Utxo>,
    ) -> Result<(), AppError> {
        let mut table_pk_2 = write_tx.open_table(UTXO_ID)?;
        for instance in instances.iter() {
            table_pk_2.insert(&instance.id, ())?;
        }
        let mut table_col_2 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
        for instance in instances.iter() {
            table_col_2.insert(&instance.id, &instance.amount)?;
        }
        let mut table_col_7 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
        for instance in instances.iter() {
            table_col_7.insert(&instance.id, &instance.datum)?;
            mm.insert(&instance.datum, &instance.id)?;
        }
        let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
        let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
        let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
        let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
        for instance in instances.iter() {
            let (birth_id, newly_created) = {
                if let Some(guard) = value_to_dict_pk.get(&instance.address)? {
                    (guard.value().clone(), false)
                } else {
                    let new_birth = instance.id.clone();
                    (new_birth, true)
                }
            };
            if newly_created {
                value_to_dict_pk.insert(&instance.address, &birth_id)?;
                value_by_dict_pk.insert(&birth_id, &instance.address)?;
            }
            dict_pk_by_pk.insert(&instance.id, &birth_id)?;
            dict_index.insert(&birth_id, &instance.id)?;
        }
        let mut children: Vec<Asset> = Vec::new();
        for instance in instances.iter() {
            children.extend_from_slice(&instance.assets)
        }
        Asset::store_many(&write_tx, &children)?;
        Ok(())
    }
    pub fn store_unsafe_and_commit(
        db: &::redb::Database,
        instance: &Utxo,
    ) -> Result<(), AppError> {
        let write_tx = db.begin_write()?;
        {
            let mut table_pk_1 = write_tx.open_table(UTXO_ID)?;
            table_pk_1.insert(&instance.id, ())?;
            let mut table_col_1 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
            table_col_1.insert(&instance.id, &instance.amount)?;
            let mut table_col_6 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.datum)?;
            let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
            mm.insert(&instance.datum, &instance.id)?;
            let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
            let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
            let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
            let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
            let (birth_id, newly_created) = {
                if let Some(guard) = value_to_dict_pk.get(&instance.address)? {
                    (guard.value().clone(), false)
                } else {
                    let new_birth = instance.id.clone();
                    (new_birth, true)
                }
            };
            if newly_created {
                value_to_dict_pk.insert(&instance.address, &birth_id)?;
                value_by_dict_pk.insert(&birth_id, &instance.address)?;
            }
            dict_pk_by_pk.insert(&instance.id, &birth_id)?;
            dict_index.insert(&birth_id, &instance.id)?;
            Asset::store_many(&write_tx, &instance.assets)?;
        }
        write_tx.commit()?;
        Ok(())
    }
    pub fn delete(
        write_tx: &::redb::WriteTransaction,
        pk: &UtxoPointer,
    ) -> Result<(), AppError> {
        let mut table_pk_3 = write_tx.open_table(UTXO_ID)?;
        let _ = table_pk_3.remove(pk)?;
        let mut table_col_3 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
        let _ = table_col_3.remove(pk)?;
        let mut table_col_8 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
        let maybe_value = {
            if let Some(value_guard) = table_col_8.remove(pk)? {
                Some(value_guard.value().clone())
            } else {
                None
            }
        };
        if let Some(value) = maybe_value {
            let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
            mm.remove(&value, pk)?;
        }
        let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
        let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
        let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
        let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
        let birth_id_opt = dict_pk_by_pk.remove(pk)?.map(|guard| guard.value().clone());
        if let Some(birth_id) = birth_id_opt {
            let value_opt = value_by_dict_pk
                .get(&birth_id)?
                .map(|guard| guard.value().clone());
            if let Some(value) = value_opt {
                dict_index.remove(&birth_id, pk)?;
                if dict_index.get(&birth_id)?.is_empty() {
                    value_to_dict_pk.remove(&value)?;
                    value_by_dict_pk.remove(&birth_id)?;
                }
            }
        }
        let (from, to) = pk.fk_range();
        let child_pks = Asset::pk_range(&write_tx, &from, &to)?;
        Asset::delete_many(&write_tx, &child_pks)?;
        Ok(())
    }
    pub fn delete_many(
        write_tx: &::redb::WriteTransaction,
        pks: &Vec<UtxoPointer>,
    ) -> Result<(), AppError> {
        let mut table_pk_4 = write_tx.open_table(UTXO_ID)?;
        for pk in pks.iter() {
            table_pk_4.remove(pk)?;
        }
        let mut table_col_4 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
        for pk in pks.iter() {
            table_col_4.remove(pk)?;
        }
        let mut table_col_9 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
        for pk in pks.iter() {
            if let Some(value_guard) = table_col_9.remove(pk)? {
                let value = value_guard.value();
                mm.remove(&value, pk)?;
            }
        }
        let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
        let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
        let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
        let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
        for pk in pks.iter() {
            let birth_id_opt = dict_pk_by_pk
                .remove(pk)?
                .map(|guard| guard.value().clone());
            if let Some(birth_id) = birth_id_opt {
                let value_opt = value_by_dict_pk
                    .get(&birth_id)?
                    .map(|guard| guard.value().clone());
                if let Some(value) = value_opt {
                    dict_index.remove(&birth_id, pk)?;
                    if dict_index.get(&birth_id)?.is_empty() {
                        value_to_dict_pk.remove(&value)?;
                        value_by_dict_pk.remove(&birth_id)?;
                    }
                }
            }
        }
        let mut children = Vec::new();
        for pk in pks.iter() {
            let (from, to) = pk.fk_range();
            let child_pks = Asset::pk_range(&write_tx, &from, &to)?;
            children.extend_from_slice(&child_pks);
        }
        Asset::delete_many(&write_tx, &children)?;
        Ok(())
    }
    pub fn delete_and_commit(
        db: &::redb::Database,
        pk: &UtxoPointer,
    ) -> Result<(), AppError> {
        let write_tx = db.begin_write()?;
        {
            let mut table_pk_3 = write_tx.open_table(UTXO_ID)?;
            let _ = table_pk_3.remove(pk)?;
            let mut table_col_3 = write_tx.open_table(UTXO_AMOUNT_BY_ID)?;
            let _ = table_col_3.remove(pk)?;
            let mut table_col_8 = write_tx.open_table(UTXO_DATUM_BY_ID)?;
            let maybe_value = {
                if let Some(value_guard) = table_col_8.remove(pk)? {
                    Some(value_guard.value().clone())
                } else {
                    None
                }
            };
            if let Some(value) = maybe_value {
                let mut mm = write_tx.open_multimap_table(UTXO_DATUM_INDEX)?;
                mm.remove(&value, pk)?;
            }
            let mut dict_pk_by_pk = write_tx.open_table(UTXO_ADDRESS_DICT_PK_BY_ID)?;
            let mut value_to_dict_pk = write_tx.open_table(UTXO_ADDRESS_TO_DICT_PK)?;
            let mut value_by_dict_pk = write_tx.open_table(UTXO_ADDRESS_BY_DICT_PK)?;
            let mut dict_index = write_tx.open_multimap_table(UTXO_ADDRESS_DICT_INDEX)?;
            let birth_id_opt = dict_pk_by_pk
                .remove(pk)?
                .map(|guard| guard.value().clone());
            if let Some(birth_id) = birth_id_opt {
                let value_opt = value_by_dict_pk
                    .get(&birth_id)?
                    .map(|guard| guard.value().clone());
                if let Some(value) = value_opt {
                    dict_index.remove(&birth_id, pk)?;
                    if dict_index.get(&birth_id)?.is_empty() {
                        value_to_dict_pk.remove(&value)?;
                        value_by_dict_pk.remove(&birth_id)?;
                    }
                }
            }
            let (from, to) = pk.fk_range();
            let child_pks = Asset::pk_range(&write_tx, &from, &to)?;
            Asset::delete_many(&write_tx, &child_pks)?;
        }
        write_tx.commit()?;
        Ok(())
    }
    pub fn routes() -> axum::Router<RequestState> {
        axum::Router::new()
            .route("/utxo/id/{value}", ::axum::routing::get(utxo_get))
            .route("/utxo?take=", ::axum::routing::get(utxo_take))
            .route("/utxo?first=", ::axum::routing::get(utxo_first))
            .route("/utxo?last=", ::axum::routing::get(utxo_last))
            .route("/utxo/id/{value}", ::axum::routing::head(utxo_exists))
            .route("/utxo/id/{value}/parent_pk", ::axum::routing::get(utxo_parent_pk))
            .route("/utxo/id?from=&until=", ::axum::routing::get(utxo_range))
            .route("/utxo/datum/{value}", ::axum::routing::get(utxo_get_by_datum))
            .route("/utxo/address/{value}", ::axum::routing::get(utxo_get_by_address))
            .route("/utxo/{value}/assets", ::axum::routing::get(utxo_get_assets))
    }
}
