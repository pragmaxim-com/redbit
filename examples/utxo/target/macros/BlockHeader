pub const BLOCKHEADER_ID: ::redb::TableDefinition<'static, Bincode<BlockPointer>, ()> = ::redb::TableDefinition::new(
    "BLOCKHEADER_ID",
);
pub const BLOCKHEADER_HASH_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<BlockPointer>,
    Bincode<Hash>,
> = ::redb::TableDefinition::new("BLOCKHEADER_HASH_BY_ID");
pub const BLOCKHEADER_HASH_INDEX: ::redb::MultimapTableDefinition<
    'static,
    Bincode<Hash>,
    Bincode<BlockPointer>,
> = ::redb::MultimapTableDefinition::new("BLOCKHEADER_HASH_INDEX");
pub const BLOCKHEADER_TIMESTAMP_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<BlockPointer>,
    Bincode<Timestamp>,
> = ::redb::TableDefinition::new("BLOCKHEADER_TIMESTAMP_BY_ID");
pub const BLOCKHEADER_TIMESTAMP_INDEX: ::redb::MultimapTableDefinition<
    'static,
    Bincode<Timestamp>,
    Bincode<BlockPointer>,
> = ::redb::MultimapTableDefinition::new("BLOCKHEADER_TIMESTAMP_INDEX");
pub const BLOCKHEADER_MERKLE_ROOT_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<BlockPointer>,
    Bincode<Hash>,
> = ::redb::TableDefinition::new("BLOCKHEADER_MERKLE_ROOT_BY_ID");
pub const BLOCKHEADER_MERKLE_ROOT_INDEX: ::redb::MultimapTableDefinition<
    'static,
    Bincode<Hash>,
    Bincode<BlockPointer>,
> = ::redb::MultimapTableDefinition::new("BLOCKHEADER_MERKLE_ROOT_INDEX");
pub const BLOCKHEADER_NONCE_BY_ID: ::redb::TableDefinition<
    'static,
    Bincode<BlockPointer>,
    Bincode<Nonce>,
> = ::redb::TableDefinition::new("BLOCKHEADER_NONCE_BY_ID");
#[axum::debug_handler]
pub async fn blockheader_get(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<BlockPointer>>,
) -> Result<AppJson<Option<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::get(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_take(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(params): ::axum::extract::Query<TakeParams>,
) -> Result<AppJson<Vec<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::take(&read_tx, params.take))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_first(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(params): ::axum::extract::Query<FirstParams>,
) -> Result<AppJson<Option<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::first(&read_tx))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_last(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(params): ::axum::extract::Query<LastParams>,
) -> Result<AppJson<Option<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::last(&read_tx))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_exists(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<BlockPointer>>,
) -> Result<AppJson<bool>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::exists(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_range(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(
        params,
    ): ::axum::extract::Query<RequestRangeParams<BlockPointer, BlockPointer>>,
) -> Result<AppJson<Vec<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::range(&read_tx, &params.from, &params.until))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_get_by_hash(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<Hash>>,
) -> Result<AppJson<Vec<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::get_by_hash(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_get_by_timestamp(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<Timestamp>>,
) -> Result<AppJson<Vec<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::get_by_timestamp(&read_tx, &params.value))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_range_by_timestamp(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Query(
        params,
    ): ::axum::extract::Query<RequestRangeParams<Timestamp, Timestamp>>,
) -> Result<AppJson<Vec<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::range_by_timestamp(
            &read_tx,
            &params.from,
            &params.until,
        ))
        .map(AppJson)
}
#[axum::debug_handler]
pub async fn blockheader_get_by_merkle_root(
    ::axum::extract::State(state): ::axum::extract::State<RequestState>,
    ::axum::extract::Path(params): ::axum::extract::Path<RequestByParams<Hash>>,
) -> Result<AppJson<Vec<BlockHeader>>, AppError> {
    state
        .db
        .begin_read()
        .map_err(AppError::from)
        .and_then(|read_tx| BlockHeader::get_by_merkle_root(&read_tx, &params.value))
        .map(AppJson)
}
impl BlockHeader {
    pub fn get(
        read_tx: &::redb::ReadTransaction,
        pk: &BlockPointer,
    ) -> Result<Option<BlockHeader>, AppError> {
        let table_pk_5 = read_tx.open_table(BLOCKHEADER_ID)?;
        if table_pk_5.get(pk)?.is_some() {
            Ok(Some(Self::compose(&read_tx, pk)?))
        } else {
            Ok(None)
        }
    }
    pub fn take(
        read_tx: &::redb::ReadTransaction,
        n: u32,
    ) -> Result<Vec<BlockHeader>, AppError> {
        let table_pk_6 = read_tx.open_table(BLOCKHEADER_ID)?;
        let mut iter = table_pk_6.iter()?;
        let mut results = Vec::new();
        let mut count = 0;
        while let Some(entry_res) = iter.next() {
            if count >= n {
                break;
            }
            let pk = entry_res?.0.value();
            results.push(Self::compose(&read_tx, &pk)?);
            count += 1;
        }
        Ok(results)
    }
    pub fn first(
        read_tx: &::redb::ReadTransaction,
    ) -> Result<Option<BlockHeader>, AppError> {
        let table_pk_7 = read_tx.open_table(BLOCKHEADER_ID)?;
        if let Some((k, _)) = table_pk_7.first()? {
            return Self::compose(&read_tx, &k.value()).map(Some);
        }
        Ok(None)
    }
    pub fn last(
        read_tx: &::redb::ReadTransaction,
    ) -> Result<Option<BlockHeader>, AppError> {
        let table_pk_8 = read_tx.open_table(BLOCKHEADER_ID)?;
        if let Some((k, _)) = table_pk_8.last()? {
            return Self::compose(&read_tx, &k.value()).map(Some);
        }
        Ok(None)
    }
    pub fn exists(
        read_tx: &::redb::ReadTransaction,
        pk: &BlockPointer,
    ) -> Result<bool, AppError> {
        let table_pk_11 = read_tx.open_table(BLOCKHEADER_ID)?;
        if table_pk_11.get(pk)?.is_some() { Ok(true) } else { Ok(false) }
    }
    pub fn range(
        read_tx: &::redb::ReadTransaction,
        from: &BlockPointer,
        until: &BlockPointer,
    ) -> Result<Vec<BlockHeader>, AppError> {
        let table_pk_9 = read_tx.open_table(BLOCKHEADER_ID)?;
        let range = from.clone()..until.clone();
        let mut iter = table_pk_9.range(range)?;
        let mut results = Vec::new();
        while let Some(entry_res) = iter.next() {
            let pk = entry_res?.0.value();
            results.push(Self::compose(&read_tx, &pk)?);
        }
        Ok(results)
    }
    fn pk_range(
        write_tx: &::redb::WriteTransaction,
        from: &BlockPointer,
        until: &BlockPointer,
    ) -> Result<Vec<BlockPointer>, AppError> {
        let table_pk_10 = write_tx.open_table(BLOCKHEADER_ID)?;
        let range = from.clone()..until.clone();
        let mut iter = table_pk_10.range(range)?;
        let mut results = Vec::new();
        while let Some(entry_res) = iter.next() {
            let pk = entry_res?.0.value();
            results.push(pk);
        }
        Ok(results)
    }
    pub fn get_by_hash(
        read_tx: &::redb::ReadTransaction,
        val: &Hash,
    ) -> Result<Vec<BlockHeader>, AppError> {
        let mm_table = read_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
        let mut iter = mm_table.get(val)?;
        let mut results = Vec::new();
        while let Some(x) = iter.next() {
            let pk = x?.value();
            match Self::compose(&read_tx, &pk) {
                Ok(item) => {
                    results.push(item);
                }
                Err(err) => {
                    return Err(AppError::Internal(err.to_string()));
                }
            }
        }
        Ok(results)
    }
    pub fn get_by_timestamp(
        read_tx: &::redb::ReadTransaction,
        val: &Timestamp,
    ) -> Result<Vec<BlockHeader>, AppError> {
        let mm_table = read_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
        let mut iter = mm_table.get(val)?;
        let mut results = Vec::new();
        while let Some(x) = iter.next() {
            let pk = x?.value();
            match Self::compose(&read_tx, &pk) {
                Ok(item) => {
                    results.push(item);
                }
                Err(err) => {
                    return Err(AppError::Internal(err.to_string()));
                }
            }
        }
        Ok(results)
    }
    pub fn range_by_timestamp(
        read_tx: &::redb::ReadTransaction,
        from: &Timestamp,
        until: &Timestamp,
    ) -> Result<Vec<BlockHeader>, AppError> {
        let mm_table = read_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
        let range_iter = mm_table.range(from.clone()..until.clone())?;
        let mut results = Vec::new();
        for entry_res in range_iter {
            let (col_key, mut multi_iter) = entry_res?;
            while let Some(x) = multi_iter.next() {
                let pk = x?.value();
                match Self::compose(&read_tx, &pk) {
                    Ok(item) => {
                        results.push(item);
                    }
                    Err(err) => {
                        return Err(AppError::Internal(err.to_string()));
                    }
                }
            }
        }
        Ok(results)
    }
    pub fn get_by_merkle_root(
        read_tx: &::redb::ReadTransaction,
        val: &Hash,
    ) -> Result<Vec<BlockHeader>, AppError> {
        let mm_table = read_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
        let mut iter = mm_table.get(val)?;
        let mut results = Vec::new();
        while let Some(x) = iter.next() {
            let pk = x?.value();
            match Self::compose(&read_tx, &pk) {
                Ok(item) => {
                    results.push(item);
                }
                Err(err) => {
                    return Err(AppError::Internal(err.to_string()));
                }
            }
        }
        Ok(results)
    }
    pub fn sample(pk: &BlockPointer) -> Self {
        BlockHeader {
            id: pk.clone(),
            hash: Hash::default(),
            timestamp: Timestamp::default(),
            merkle_root: Hash::default(),
            nonce: Nonce::default(),
        }
    }
    fn compose(
        read_tx: &::redb::ReadTransaction,
        pk: &BlockPointer,
    ) -> Result<BlockHeader, AppError> {
        Ok(BlockHeader {
            id: pk.clone(),
            hash: {
                let table_col_10 = read_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
                let guard = table_col_10.get(pk)?;
                guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table `{}`: no row for primary key {:?}",
                            stringify!(BLOCKHEADER_HASH_BY_ID), pk
                        ),
                    ))?
                    .value()
            },
            timestamp: {
                let table_col_10 = read_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
                let guard = table_col_10.get(pk)?;
                guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table `{}`: no row for primary key {:?}",
                            stringify!(BLOCKHEADER_TIMESTAMP_BY_ID), pk
                        ),
                    ))?
                    .value()
            },
            merkle_root: {
                let table_col_10 = read_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
                let guard = table_col_10.get(pk)?;
                guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table `{}`: no row for primary key {:?}",
                            stringify!(BLOCKHEADER_MERKLE_ROOT_BY_ID), pk
                        ),
                    ))?
                    .value()
            },
            nonce: {
                let table_col_5 = read_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
                let guard = table_col_5.get(pk)?;
                guard
                    .ok_or_else(|| AppError::NotFound(
                        format!(
                            "table `{}`: no row for primary key {:?}",
                            stringify!(BLOCKHEADER_NONCE_BY_ID), pk
                        ),
                    ))?
                    .value()
            },
        })
    }
    pub fn store(
        write_tx: &::redb::WriteTransaction,
        instance: &BlockHeader,
    ) -> Result<(), AppError> {
        if is_one_to_many_child && instance.exists(id.parent()) {
            let mut table_pk_1 = write_tx.open_table(BLOCKHEADER_ID)?;
            table_pk_1.insert(&instance.id, ())?;
            let mut table_col_6 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.hash)?;
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
            mm.insert(&instance.hash, &instance.id)?;
            let mut table_col_6 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.timestamp)?;
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
            mm.insert(&instance.timestamp, &instance.id)?;
            let mut table_col_6 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.merkle_root)?;
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
            mm.insert(&instance.merkle_root, &instance.id)?;
            let mut table_col_1 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
            table_col_1.insert(&instance.id, &instance.nonce)?;
            Ok(())
        } else {
            Err(
                AppError::InvalidPrimaryKey(
                    format!(
                        "Cannot store {} with no primary key", stringify!(BlockHeader)
                    ),
                ),
            )
        }
    }
    pub fn store(
        write_tx: &::redb::WriteTransaction,
        instance: &BlockHeader,
    ) -> Result<(), AppError> {
        let mut table_pk_1 = write_tx.open_table(BLOCKHEADER_ID)?;
        table_pk_1.insert(&instance.id, ())?;
        let mut table_col_6 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
        table_col_6.insert(&instance.id, &instance.hash)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
        mm.insert(&instance.hash, &instance.id)?;
        let mut table_col_6 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
        table_col_6.insert(&instance.id, &instance.timestamp)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
        mm.insert(&instance.timestamp, &instance.id)?;
        let mut table_col_6 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
        table_col_6.insert(&instance.id, &instance.merkle_root)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
        mm.insert(&instance.merkle_root, &instance.id)?;
        let mut table_col_1 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
        table_col_1.insert(&instance.id, &instance.nonce)?;
        Ok(())
    }
    pub fn store_many(
        write_tx: &::redb::WriteTransaction,
        instances: &Vec<BlockHeader>,
    ) -> Result<(), AppError> {
        let mut table_pk_2 = write_tx.open_table(BLOCKHEADER_ID)?;
        for instance in instances.iter() {
            table_pk_2.insert(&instance.id, ())?;
        }
        let mut table_col_7 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
        for instance in instances.iter() {
            table_col_7.insert(&instance.id, &instance.hash)?;
            mm.insert(&instance.hash, &instance.id)?;
        }
        let mut table_col_7 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
        for instance in instances.iter() {
            table_col_7.insert(&instance.id, &instance.timestamp)?;
            mm.insert(&instance.timestamp, &instance.id)?;
        }
        let mut table_col_7 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
        for instance in instances.iter() {
            table_col_7.insert(&instance.id, &instance.merkle_root)?;
            mm.insert(&instance.merkle_root, &instance.id)?;
        }
        let mut table_col_2 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
        for instance in instances.iter() {
            table_col_2.insert(&instance.id, &instance.nonce)?;
        }
        Ok(())
    }
    pub fn store_unsafe_and_commit(
        db: &::redb::Database,
        instance: &BlockHeader,
    ) -> Result<(), AppError> {
        let write_tx = db.begin_write()?;
        {
            let mut table_pk_1 = write_tx.open_table(BLOCKHEADER_ID)?;
            table_pk_1.insert(&instance.id, ())?;
            let mut table_col_6 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.hash)?;
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
            mm.insert(&instance.hash, &instance.id)?;
            let mut table_col_6 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.timestamp)?;
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
            mm.insert(&instance.timestamp, &instance.id)?;
            let mut table_col_6 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
            table_col_6.insert(&instance.id, &instance.merkle_root)?;
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
            mm.insert(&instance.merkle_root, &instance.id)?;
            let mut table_col_1 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
            table_col_1.insert(&instance.id, &instance.nonce)?;
        }
        write_tx.commit()?;
        Ok(())
    }
    pub fn delete(
        write_tx: &::redb::WriteTransaction,
        pk: &BlockPointer,
    ) -> Result<(), AppError> {
        let mut table_pk_3 = write_tx.open_table(BLOCKHEADER_ID)?;
        let _ = table_pk_3.remove(pk)?;
        let mut table_col_8 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
        let maybe_value = {
            if let Some(value_guard) = table_col_8.remove(pk)? {
                Some(value_guard.value().clone())
            } else {
                None
            }
        };
        if let Some(value) = maybe_value {
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
            mm.remove(&value, pk)?;
        }
        let mut table_col_8 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
        let maybe_value = {
            if let Some(value_guard) = table_col_8.remove(pk)? {
                Some(value_guard.value().clone())
            } else {
                None
            }
        };
        if let Some(value) = maybe_value {
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
            mm.remove(&value, pk)?;
        }
        let mut table_col_8 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
        let maybe_value = {
            if let Some(value_guard) = table_col_8.remove(pk)? {
                Some(value_guard.value().clone())
            } else {
                None
            }
        };
        if let Some(value) = maybe_value {
            let mut mm = write_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
            mm.remove(&value, pk)?;
        }
        let mut table_col_3 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
        let _ = table_col_3.remove(pk)?;
        Ok(())
    }
    pub fn delete_many(
        write_tx: &::redb::WriteTransaction,
        pks: &Vec<BlockPointer>,
    ) -> Result<(), AppError> {
        let mut table_pk_4 = write_tx.open_table(BLOCKHEADER_ID)?;
        for pk in pks.iter() {
            table_pk_4.remove(pk)?;
        }
        let mut table_col_9 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
        for pk in pks.iter() {
            if let Some(value_guard) = table_col_9.remove(pk)? {
                let value = value_guard.value();
                mm.remove(&value, pk)?;
            }
        }
        let mut table_col_9 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
        for pk in pks.iter() {
            if let Some(value_guard) = table_col_9.remove(pk)? {
                let value = value_guard.value();
                mm.remove(&value, pk)?;
            }
        }
        let mut table_col_9 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
        let mut mm = write_tx.open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
        for pk in pks.iter() {
            if let Some(value_guard) = table_col_9.remove(pk)? {
                let value = value_guard.value();
                mm.remove(&value, pk)?;
            }
        }
        let mut table_col_4 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
        for pk in pks.iter() {
            table_col_4.remove(pk)?;
        }
        Ok(())
    }
    pub fn delete_and_commit(
        db: &::redb::Database,
        pk: &BlockPointer,
    ) -> Result<(), AppError> {
        let write_tx = db.begin_write()?;
        {
            let mut table_pk_3 = write_tx.open_table(BLOCKHEADER_ID)?;
            let _ = table_pk_3.remove(pk)?;
            let mut table_col_8 = write_tx.open_table(BLOCKHEADER_HASH_BY_ID)?;
            let maybe_value = {
                if let Some(value_guard) = table_col_8.remove(pk)? {
                    Some(value_guard.value().clone())
                } else {
                    None
                }
            };
            if let Some(value) = maybe_value {
                let mut mm = write_tx.open_multimap_table(BLOCKHEADER_HASH_INDEX)?;
                mm.remove(&value, pk)?;
            }
            let mut table_col_8 = write_tx.open_table(BLOCKHEADER_TIMESTAMP_BY_ID)?;
            let maybe_value = {
                if let Some(value_guard) = table_col_8.remove(pk)? {
                    Some(value_guard.value().clone())
                } else {
                    None
                }
            };
            if let Some(value) = maybe_value {
                let mut mm = write_tx.open_multimap_table(BLOCKHEADER_TIMESTAMP_INDEX)?;
                mm.remove(&value, pk)?;
            }
            let mut table_col_8 = write_tx.open_table(BLOCKHEADER_MERKLE_ROOT_BY_ID)?;
            let maybe_value = {
                if let Some(value_guard) = table_col_8.remove(pk)? {
                    Some(value_guard.value().clone())
                } else {
                    None
                }
            };
            if let Some(value) = maybe_value {
                let mut mm = write_tx
                    .open_multimap_table(BLOCKHEADER_MERKLE_ROOT_INDEX)?;
                mm.remove(&value, pk)?;
            }
            let mut table_col_3 = write_tx.open_table(BLOCKHEADER_NONCE_BY_ID)?;
            let _ = table_col_3.remove(pk)?;
        }
        write_tx.commit()?;
        Ok(())
    }
    pub fn routes() -> axum::Router<RequestState> {
        axum::Router::new()
            .route("/blockheader/id/{value}", ::axum::routing::get(blockheader_get))
            .route("/blockheader?take=", ::axum::routing::get(blockheader_take))
            .route("/blockheader?first=", ::axum::routing::get(blockheader_first))
            .route("/blockheader?last=", ::axum::routing::get(blockheader_last))
            .route("/blockheader/id/{value}", ::axum::routing::head(blockheader_exists))
            .route(
                "/blockheader/id?from=&until=",
                ::axum::routing::get(blockheader_range),
            )
            .route(
                "/blockheader/hash/{value}",
                ::axum::routing::get(blockheader_get_by_hash),
            )
            .route(
                "/blockheader/timestamp/{value}",
                ::axum::routing::get(blockheader_get_by_timestamp),
            )
            .route(
                "/blockheader/timestamp?from=&until=",
                ::axum::routing::get(blockheader_range_by_timestamp),
            )
            .route(
                "/blockheader/merkle_root/{value}",
                ::axum::routing::get(blockheader_get_by_merkle_root),
            )
    }
}
