use crate::entity::EntityMacros;
use crate::rest::{to_http_endpoints, FunctionDef};
use crate::macro_utils;
use proc_macro2::{Ident, Literal, TokenStream};
use quote::{format_ident, quote};

pub fn expand(entity_macros: EntityMacros) -> TokenStream {
    let entity_name = &entity_macros.entity_name;
    let entity_type = &entity_macros.entity_type;
    let db_pk_macros = &entity_macros.pk;

    let table_definitions = entity_macros.table_definitions();
    let column_struct_inits_by_name: Vec<(Ident, TokenStream)> = entity_macros.column_struct_inits();
    let mut struct_inits: Vec<TokenStream> =
        column_struct_inits_by_name.iter().map(|(field_name, macro_stream)| quote! { #field_name: #macro_stream }).collect();
    let non_column_struct_inits: Vec<TokenStream> = entity_macros.non_column_inits();
    struct_inits.extend(non_column_struct_inits.clone());
    let struct_default_inits = entity_macros.struct_default_inits();
    let function_defs: Vec<FunctionDef> = entity_macros.function_defs();
    let stream_query_field_defs: Vec<TokenStream> = entity_macros.stream_query_field_defs();
    let stream_query_field_inits: Vec<TokenStream> = entity_macros.stream_query_field_inits();

    let store_statements = entity_macros.store_statements();
    let store_many_statements = entity_macros.store_many_statements();
    let delete_statements = entity_macros.delete_statements();
    let delete_many_statements = entity_macros.delete_many_statements();

    let queries = entity_macros.queries();

    let function_streams: Vec<TokenStream> = function_defs.iter().map(|f| f.fn_stream.clone()).collect::<Vec<_>>();
    let table_definition_streams: Vec<TokenStream> = table_definitions.iter().map(|table_def| table_def.definition.clone()).collect();
    let tests = function_defs.iter().filter_map(|f| f.test_stream.clone()).collect::<Vec<_>>();
    let (endpoint_handlers, route_chains, route_tests) = to_http_endpoints(function_defs);

    let table_lines = table_definitions.iter().map(|table_def| format!("| Table         |  {}", table_def.name)).collect();
    macro_utils::write_to_local_file(table_lines, "tables", &entity_name);

    let pk_name = db_pk_macros.definition.field.name.clone();
    let pk_type = db_pk_macros.definition.field.tpe.clone();
    let entity_tests = format_ident!("{}_tests", entity_name.to_string().to_lowercase());
    let entity_literal = Literal::string(&entity_name.to_string());
    let entity_streaming_query = format_ident!("{}StreamQuery", entity_name.to_string());

    let field_check_blocks: Vec<TokenStream> = column_struct_inits_by_name.iter().map(|(field_ident, init_expr)| {
        quote! {
        {
            let value = { #init_expr };
            if let Some(expected) = streaming_query.#field_ident.clone() {
                if expected != value {
                    return Ok(None);
                }
            }
            Ok(value)
        }
    }
    }).collect();

    // turn &[Ident] into Vec<Ident>
    let field_idents: Vec<Ident> = column_struct_inits_by_name
        .iter()
        .map(|(ident, _)| ident.clone())
        .collect();

    // build a usize literal for the Vec capacity
    let capacity = Literal::usize_unsuffixed(field_idents.len());

    let expanded = quote! {
        // for filtering streaming queries
        #[derive(IntoParams, Serialize, Deserialize, Default)]
        pub struct #entity_streaming_query {
            #(#stream_query_field_defs),*
        }
        impl #entity_streaming_query {
            pub fn sample() -> Self {
                Self {
                    #(#stream_query_field_inits),*
                }
            }
        }

        // table definitions are not in the impl object because they are accessed globally with semantic meaning
        #(#table_definition_streams)*

        // utoipa and axum query structs to map query and path params into
        #(#queries)*

        // axum endpoints cannot be in the impl object https://docs.rs/axum/latest/axum/attr.debug_handler.html#limitations
        #(#endpoint_handlers)*

        impl #entity_name {
            #(#function_streams)*

            pub fn sample() -> Self {
                #entity_name::sample_with(&#pk_type::default(), 0)
            }

            pub fn sample_with(pk: &#pk_type, sample_index: usize) -> Self {
                #entity_name {
                    #pk_name: pk.clone(),
                    #(#struct_default_inits),*
                }
            }

            pub fn sample_many(n: usize) -> Vec<#entity_type> {
                let mut sample_index = 0;
                std::iter::successors(Some((#pk_type::default(), None)), |(prev_pointer, _)| {
                    let new_entity = #entity_type::sample_with(prev_pointer, sample_index);
                    sample_index += 1;
                    Some((prev_pointer.next(), Some(new_entity)))
                })
                .filter_map(|(_, instance)| instance)
                .take(n)
                .collect()
            }

            fn compose(tx: &ReadTransaction, pk: &#pk_type) -> Result<#entity_type, AppError> {
                Ok(#entity_name {
                    #pk_name: pk.clone(),
                    #(#struct_inits),*
                })
            }

            fn compose_with_filter(
                tx: &ReadTransaction,
                pk: &#pk_type,
                streaming_query: #entity_streaming_query,
            ) -> Result<Option<#entity_type>, AppError> {
                let field_values = [
                    #(#field_check_blocks),*
                ].into_iter().try_fold(
                    Vec::with_capacity(#capacity),
                    |mut acc, res| {
                        res.map(|v| {
                            acc.push(v);
                            acc
                        })
                    }
                )?;

                let mut it = field_values.into_iter();

                Ok(Some(#entity_type {
                    #pk_name: pk.clone(),
                    #(
                        #field_idents: it.next().unwrap(),
                    )*

                    // *then* your hand‑written, non‑column fields
                    #(#non_column_struct_inits),*
                }))
            }

            pub fn store(tx: &WriteTransaction, instance: &#entity_type) -> Result<(), AppError> {
                #(#store_statements)*
                Ok(())
            }

            pub fn store_many(tx: &WriteTransaction, instances: &Vec<#entity_type>) -> Result<(), AppError> {
                #(#store_many_statements)*
                Ok(())
            }

            pub fn delete(tx: &WriteTransaction, pk: &#pk_type) -> Result<(), AppError> {
                #(#delete_statements)*
                Ok(())
            }

            pub fn delete_many(tx: &WriteTransaction, pks: &Vec<#pk_type>) -> Result<(), AppError> {
                #(#delete_many_statements)*
                Ok(())
            }

            pub fn routes() -> OpenApiRouter<RequestState> {
                OpenApiRouter::new()
                    #(#route_chains)*
            }
        }

    # [cfg(test)]
    mod # entity_tests {
        use super::*;

        fn init_temp_db(name: &str) -> Arc<Database> {
        let dir = std::env::temp_dir().join("redbit").join(name).join( # entity_literal);
        if ! dir.exists() {
        std::fs::create_dir_all(dir.clone()).unwrap();
        }
        let db_path = dir.join(format ! ("{}_{}.redb", # entity_literal, rand::random::<u64 > ()));
        Arc::new(Database::create(db_path).expect("Failed to create database"))
        }

        #[tokio::test]
        async fn test_entity_api() {
        let db = init_temp_db("api");
        let entity_count: usize = 3;
        # ( # tests)*
        }

        #[tokio::test]
        async fn test_entity_rest_api() {
        let db = init_temp_db("rest-api");
        let router = build_router(RequestState { db: Arc::clone( & db) }, None).await;
        let server = axum_test::TestServer::new(router).unwrap();
        # ( # route_tests) *
        }
    }
};
// eprintln!("----------------------------------------------------------");
macro_utils::write_stream_and_return(expanded, & entity_name)
}
